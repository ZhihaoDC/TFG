# -*- coding: utf-8 -*-
"""comparativeAnalysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DF5xNWZy_BinhkRvqO1p4IiEwRNCnZbv
"""

# Commented out IPython magic to ensure Python compatibility.
# =============================================================================
# from google.colab import drive
# drive.mount('/gdrive')
# =============================================================================

# %cd /gdrive/My Drive/Github/TFG/source

# !git pull https://github.com/ZhihaoDC/TFG

#Import custom python files
import girvan_newman as girvan_newman
import louvain as louvain

#Import libraries
import networkx as nx
import pandas as pd
import time

def running_time(start_time, end_time):
  running_time = end_time - start_time
  running_time_minutes = running_time // 60
  running_time_seconds = running_time % 60

  return (running_time_minutes, running_time_seconds)

"""#Zachary's karate club"""

#Read Graph
karate = nx.karate_club_graph()
# =============================================================================
# pos_karate = nx.spring_layout(karate) #layout for karate graph
# =============================================================================

#Girvan Newman Algorithm
start_time = time.time()
GN_karate_dendrogram, GN_modularity = girvan_newman.Girvan_Newman_2004(karate)
end_time = time.time()
min, sec = running_time(start_time, end_time)
print('Running time: ', min,'min ', sec,'s', sep='')
print('Modularity:', GN_modularity)
#Plot Girvan Newman communities
GN_communities = girvan_newman.dendrogram_to_community(GN_karate_dendrogram)
# =============================================================================
# girvan_newman.draw_communities_fixed_pos(karate, GN_communities, pos_karate)
# =============================================================================

#Louvain method
start_time = time.time()
LV_supergraph, LV_communities = louvain.Louvain(karate)
end_time = time.time()
min, sec = running_time(start_time, end_time)
print('Running time: ', min,'min ', sec,'s', sep='')
LV_last_community_karate = louvain.last_community(karate, LV_communities)
print('Modularity:', nx.algorithms.community.quality.modularity(karate,louvain.dendrogram(LV_last_community_karate)))
# =============================================================================
# louvain.draw_communities_fixed_pos(karate, LV_last_community_karate, pos_karate)
# =============================================================================

"""#Marvel Comics Social Network"""

nodes = pd.read_csv('../datasets/marvel-social-network/nodes.csv') #Node name and type
edges = pd.read_csv('../datasets/marvel-social-network/edges.csv') #Heroes and the comic in which they appear
heroes = pd.read_csv('../datasets/marvel-social-network/hero-network.csv') # Edges between heroes that appear in the same comic

heroes.head(10)

#Remove leading and trailing spaces

nodes = nodes.applymap(lambda x: x.strip())
edges = edges.applymap(lambda x: x.strip())
heroes = heroes.applymap(lambda x: x.strip())

heroes.loc[ heroes['hero2']==' ' ].shape[0]

#Number of times IronMan/TonyStark has appeared in another hero's comic
heroes.loc[ heroes['hero1']=='IRON MAN/TONY STARK' ].shape[0]

# Number of times Spiderman/PeterParker appeared in the same comic as IronMan/TonyStark
heroes.loc[ (heroes['hero1']=='SPIDER-MAN/PETER PAR') & (heroes['hero2']=='IRON MAN/TONY STARK') ].shape[0]

# Number of times IronMan/TonyStark appeared in the same comic as Spiderman/PeterParker
heroes.loc[ (heroes['hero1'] == 'IRON MAN/TONY STARK') & (heroes['hero2'] == 'SPIDER-MAN/PETER PAR') ].shape[0]

"""These two values may be different because of the structure of the edgelist. Maybe a relationship of (hero1=Spiderman, hero2=Ironman) indicates an occurence of Spiderman appearing in an Ironman comic."""

#Number different comics in which IronMan/TonyStark has appeared in 
ironman_h1 = heroes.loc[heroes['hero1'] == 'IRON MAN/TONY STARK'].drop_duplicates()
ironman_h1.shape[0]

#Number different heroes that have appeared in a IronMan/TonyStark comic
ironman_h2 = heroes.loc[heroes['hero2'] == 'IRON MAN/TONY STARK'].drop_duplicates()
ironman_h2.shape[0]

#Number of times IronMan has been involved in his or other heroes' comics
ironman_merge = pd.merge(ironman_h1, ironman_h2, how='outer', left_on='hero2', right_on='hero1')
ironman_merge.shape[0]

"""Since we are interested in a non directed graph, we will ignore this fact for the moment"""

heroes = heroes.drop_duplicates()

#Generate graph
marvel = nx.from_pandas_edgelist(heroes, source='hero1', target='hero2') 
marvel = marvel.to_undirected(marvel) # Unweighted undirected graph

print(nx.info(marvel))

"""The graph density of simple graphs is defined to be the ratio of the number of edges  |E|  with respect to the maximum possible edges For undirected simple graphs, the graph density is:

${\displaystyle D={\frac {|E|}{\binom {|V|}{2}}}={\frac {2|E|}{|V|(|V|-1)}}}$

where E is the number of edges and V is the number of vertices in the graph.

The maximum number of edges for an undirected graph is ${\displaystyle {\binom {|V|}{2}}={\frac{|V|(|V|-1)}{2}}}$ , so the maximal density is 1 (for complete graphs) and the minimal density is 0
"""

def graph_density(n_vertex, n_edges):
  return (2*n_edges / (n_vertex * (n_vertex - 1)) )

density = graph_density(marvel.number_of_nodes(), marvel.number_of_edges())
print(density)

#Check graph generation

# #Previously seen:
# #Number of times IronMan has been involved in his or other heroes' comics
# ironman_merge = pd.merge(ironman_h1, ironman_h2, how='outer', left_on='hero2', right_on='hero1')
# ironman_merge.shape[0] 
# #Out: 1521

len(list(marvel.edges('IRON MAN/TONY STARK')))

#Girvan-Newman
start_time = time.time()
GN_marvel_dendrogram, GN_modularity = girvan_newman.Girvan_Newman_2004(marvel)
end_time = time.time()
min, sec = running_time(start_time, end_time)
print('Running time: ', min,'min ', sec,'s', sep='')
print('Modularity:', GN_modularity)
#Plot Girvan Newman communities
GN_communities = girvan_newman.dendrogram_to_community(GN_marvel_dendrogram)

marvel_GN = marvel.copy()
nx.set_node_attributes(marvel_GN, GN_communities, 'community')
nx.write_gexf(marvel, "louvain_marvel_GN.gexf", version="1.2draft")

#Louvain method
start_time = time.time()
LV_supergraph, LV_communities = louvain.Louvain(marvel)
end_time = time.time()
min, sec = running_time(start_time, end_time)
print('Running time: ', min,'min ', sec,'s', sep='')
LV_last_community = louvain.last_community(marvel, LV_communities)
print('Modularity:', nx.algorithms.community.quality.modularity(marvel,louvain.dendrogram(LV_last_community)))
# louvain.draw_communities_fixed_pos(karate, LV_last_community, pos_karate)

marvel_LV = marvel.copy()
nx.set_node_attributes(marvel_LV, LV_last_community, 'community')
nx.write_gexf(marvel_LV, "louvain_marvel.gexf", version="1.2draft")

louvain.dendrogram(LV_last_community)

for community in louvain.dendrogram(LV_last_community):
  print(len(community))

import community as community_louvain
best_partition = community_louvain.best_partition(marvel)
nx.algorithms.community.quality.modularity(marvel,louvain.dendrogram(best_partition))
marvel_LV_nx = marvel.copy()
nx.set_node_attributes(marvel_LV_nx, best_partition, 'community')
nx.write_gexf(marvel_LV, "louvain_marvel_nx.gexf", version="1.2draft")